<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hand Detection</title>

  <!-- Import MediaPipe and Drawing Utilities -->
  <script src="./Hand Detection2_files/drawing_utils.js.descarga" crossorigin="anonymous"></script>
  <script src="./Hand Detection2_files/hands.js.descarga" crossorigin="anonymous"></script>

  <!-- Minimal CSS to center video and canvas -->
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }
    video, canvas {
      position: absolute;
      transform: rotateY(180deg); /* Mirror video and canvas */
    }
  </style>
</head>
<body>

  <!-- Video and Canvas Elements for Real-Time Detection -->
  <video id="webcam" autoplay playsinline></video>
  <canvas id="output_canvas"></canvas>

  <!-- Main JavaScript for Hand Landmark Detection -->
  <script type="module">
    import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

    let handLandmarker;
    let runningMode = "VIDEO";
    let lastVideoTime = -1;

    const initializeHandLandmarker = async () => {
      const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          delegate: "GPU"
        },
        runningMode: runningMode,
        numHands: 2
      });
    };
    initializeHandLandmarker();

    const video = document.getElementById("webcam");
    const canvas = document.getElementById("output_canvas");
    const canvasCtx = canvas.getContext("2d");

    if (navigator.mediaDevices?.getUserMedia) {
      navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
        video.srcObject = stream;
        video.addEventListener("loadeddata", predictWebcam);
      });
    }

    async function predictWebcam() {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;

      if (handLandmarker && video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;

        const results = await handLandmarker.detectForVideo(video, performance.now());
        canvasCtx.clearRect(0, 0, canvas.width, canvas.height);

        if (results.landmarks) {
          for (const landmarks of results.landmarks) {
            // Dibujar conexiones y landmarks
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: "#00FF00", lineWidth: 5 });
            drawLandmarks(canvasCtx, landmarks, { color: "#FF0000", lineWidth: 2 });

            // **Punto verde en la punta del dedo Ã­ndice**
            const indexTip = landmarks[8];
            const indexX = indexTip.x * canvas.width;
            const indexY = indexTip.y * canvas.height;
            canvasCtx.beginPath();
            canvasCtx.arc(indexX, indexY, 10, 0, 2 * Math.PI);
            canvasCtx.fillStyle = "#00FF00";
            canvasCtx.fill();
            canvasCtx.closePath();

            // Opcional: Mostrar coordenadas de cada landmark
            landmarks.forEach((landmark, index) => {
              const { x, y, z } = landmark;
              const canvasX = x * canvas.width;
              const canvasY = y * canvas.height;
              canvasCtx.fillStyle = "#0000FF";
              canvasCtx.font = "12px Arial";
              canvasCtx.fillText(`(${canvasX.toFixed(1)}, ${canvasY.toFixed(1)}, ${z.toFixed(2)})`, canvasX, canvasY);
            });
          }
        }
      }

      requestAnimationFrame(predictWebcam);
    }
  </script>

  <script src="./Hand Detection2_files/vision_wasm_internal.js.descarga" crossorigin="anonymous"></script>
</body>
</html>
